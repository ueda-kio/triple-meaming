# CLAUDE.md - AI Agent開発品質ガイドライン

このファイルは Claude Code の動作指針を定義します。AI Agentによるコード生成の品質向上と技術的負債の抑制を目的とした実践的ガイドラインです。

## 基本方針

AI Agentによる開発では以下の原則を厳格に遵守してください：

- **品質ファースト**: 動作するだけでなく、保守可能なコードを生成する
- **テスト駆動**: 実装と同時にテストコードを必ず作成する
- **段階的実装**: 大きなコンポーネントを避け、小さな単位で実装する
- **継続的リファクタリング**: 技術的負債を放置せず、定期的に改善する

## コード品質基準

### 1. コンポーネント設計原則

#### 単一責任原則の厳守
- **1コンポーネント = 200行以内**: これを超える場合は責任分離を検討
- **1つの関心事のみ**: UI表示、状態管理、データ取得を混在させない
- **propsは10個以内**: 過度なprops受け渡しは設計見直しのサイン

```typescript
// 悪い例：複数の責任が混在
function LargeComponent({ data, onSubmit, onCancel, settings, validation, ... }) {
  // UI表示 + データ処理 + 状態管理が混在
}

// 良い例：責任を分離
function DataDisplayComponent({ data }: { data: Data }) {
  // UI表示のみに集中
}

function DataProcessorHook() {
  // データ処理ロジックを分離
}
```

#### フック使用の最適化
- **useStateは5個以内/コンポーネント**: 状態管理の複雑化を防ぐ
- **useEffectは3個以内/コンポーネント**: 副作用の責任を明確化
- **カスタムフック抽出**: 複雑な状態ロジックは独立したフックに分離

```typescript
// 悪い例：useState/useEffectの過度な使用
function ComplexComponent() {
  const [state1, setState1] = useState();
  const [state2, setState2] = useState();
  const [state3, setState3] = useState();
  const [state4, setState4] = useState();
  const [state5, setState5] = useState();
  const [state6, setState6] = useState(); // 多すぎ！
  
  useEffect(() => {}, [state1]);
  useEffect(() => {}, [state2]);
  useEffect(() => {}, [state3]);
  useEffect(() => {}, [state4]); // 多すぎ！
}

// 良い例：カスタムフックで状態を整理
function useFormState() {
  // 関連する状態をまとめて管理
}

function useDataFetching() {
  // データ取得関連の状態を分離
}
```

### 2. テストコード必須要件

### 原則
テストコードを「動作する仕様書」、つまりテストコードを読むことで仕様が明確になるよう設計すること。
仕様書としての可読性を担保するため、テストスイートごとに適切なグルーピングと階層化を行うこと。

#### 実装と同時のテスト作成
- **新コンポーネント**: 必ず対応するテストファイルを作成
- **新カスタムフック**: フックの動作をテストで検証
- **新ユーティリティ関数**: 純粋関数は100%テストカバレッジを目指す

#### テストパターン別要件
```typescript
// コンポーネントテストの必須項目
describe('ComponentName', () => {
  it('正常にレンダリングされること', () => {
    // レンダリングテスト
  });
  
  it('props変更時に適切に更新されること', () => {
    // props変更テスト
  });
  
  it('ユーザー操作に正しく反応すること', () => {
    // インタラクションテスト
  });
  
  it('エラー状態を適切に処理すること', () => {
    // エラーハンドリングテスト
  });
});

// カスタムフックテストの必須項目
describe('useCustomHook', () => {
  it('初期状態が正しく設定されること', () => {
    // 初期化テスト
  });
  
  it('状態変更が正しく動作すること', () => {
    // 状態変更テスト
  });
  
  it('副作用が適切に実行されること', () => {
    // 副作用テスト
  });
});
```

#### テスト品質基準
- **console.log使用禁止**: テストコード内でのデバッグコード残存を防ぐ
- **意図的なテスト名**: 何をテストしているかが明確であること
- **モックの適切な使用**: 外部依存を正しく分離すること

### 3. コード重複排除（DRY原則）

#### 共通コンポーネントの抽出基準
- **3回以上の重複**: 同様のUIパターンが3箇所以上で出現したら共通化
- **50行以上の重複**: 大きなコードブロックの重複は即座に共通化

```typescript
// 悪い例：モーダルの重複実装
function ConfirmModal() {
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="fixed inset-0 bg-black bg-opacity-50" onClick={onClose} />
      {/* モーダル内容 */}
    </div>
  );
}

function AlertModal() {
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="fixed inset-0 bg-black bg-opacity-50" onClick={onClose} />
      {/* ほぼ同じ構造 */}
    </div>
  );
}

// 良い例：共通基底コンポーネント
function BaseModal({ children, onClose }: ModalProps) {
  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center">
      <div className="fixed inset-0 bg-black bg-opacity-50" onClick={onClose} />
      <div className="modal-content">{children}</div>
    </div>
  );
}
```

#### ユーティリティ関数の共通化
- **計算ロジック**: 同じ計算が複数箇所で発生したら関数化
- **バリデーション**: 入力検証ロジックは再利用可能な形で実装
- **データ変換**: APIレスポンス変換等は共通ユーティリティに集約

### 4. パフォーマンス最適化原則

#### レンダリング最適化
- **React.memo**: propsが変わらない限り再レンダリングを防ぐ
- **useMemo/useCallback**: 重い計算や関数の再生成を防ぐ
- **適切な依存配列**: useEffectの依存配列を正確に設定

```typescript
// パフォーマンス最適化の例
const MemoizedComponent = React.memo(function OptimizedComponent({ data }) {
  const expensiveValue = useMemo(() => {
    return heavyComputation(data);
  }, [data]);

  const handleClick = useCallback(() => {
    // イベントハンドラの再生成を防ぐ
  }, []);

  return <div onClick={handleClick}>{expensiveValue}</div>;
});
```

#### バンドルサイズ最適化
- **動的インポート**: 大きなライブラリは必要時のみ読み込み
- **Tree shaking**: 未使用エクスポートの除去
- **開発時ライブラリ分離**: 本番ビルドに不要なコードの除外

### 5. 本番環境対応

#### デバッグコード完全除去
- **console.log/warn/error**: 本番ビルド時に自動除去される仕組みを構築
- **開発時限定コード**: NODE_ENVによる条件分岐で本番除外
- **テスト用コード**: テストコード内でのみ使用

```typescript
// 本番環境対応の例
const debugLog = (message: string) => {
  if (process.env.NODE_ENV === 'development') {
    console.log(message);
  }
};

// または完全除去
```

#### エラーハンドリング統一
- **エラー境界**: 予期しないエラーからアプリを保護
- **ユーザー向けメッセージ**: 技術的エラーをユーザーフレンドリーに変換
- **エラートラッキング**: 本番環境でのエラー監視体制

## 実装フロー

### 1. 設計フェーズ（実装前）
1. **コンポーネント責任分離**: 実装前に責任範囲を明確化
2. **テストケース設計**: 実装前にテストシナリオを作成
3. **共通化検討**: 既存コードとの重複可能性を事前チェック

### 2. 実装フェーズ
1. **最小単位実装**: 小さなコンポーネントから段階的に構築
2. **同時テスト作成**: 実装と並行してテストコードを作成
3. **定期的リファクタリング**: 200行を超えたら即座に分割検討

### 3. 品質チェックフェーズ（実装後必須）
1. **テストカバレッジ確認**: 主要ロジックが適切にテストされているか
2. **パフォーマンス検証**: 不要な再レンダリングが発生していないか
3. **コード重複チェック**: DRY原則が守られているか
4. **デバッグコード除去**: 本番環境に不要なコードが含まれていないか

## 品質チェックリスト

実装完了時には以下を必ず確認：

### コード品質
- [ ] useState/useEffectの使用数が適切（5個/3個以内）
- [ ] 単一責任原則が守られている
- [ ] propsの数が適切

### テスト品質
- [ ] 新規コンポーネント/フックにテストが存在する
- [ ] テストカバレッジが適切（最低70%以上）
- [ ] エラーケースのテストが含まれている
- [ ] すべてのテストを実行して成功している

### パフォーマンス
- [ ] 不要な再レンダリングが発生していない
- [ ] 重い計算がメモ化されている
- [ ] 大きなライブラリが適切に分割されている
- [ ] 画像は next/image を使用して最適化されている

### 保守性
- [ ] コードの重複が適切に排除されている
- [ ] 意図が明確な命名がされている
- [ ] エラーハンドリングが一貫している
- [ ] 本番環境用の設定が適切

### 本番対応
- [ ] デバッグコードが完全に除去されている
- [ ] エラー監視が適切に設定されている
- [ ] セキュリティ考慮が適切
- [ ] パフォーマンス監視が設定されている

## AI Agent活用時の注意事項

### 避けるべきパターン
1. **機能追加時の既存コード無視**: 新機能実装時も既存アーキテクチャを尊重
2. **テスト後付け**: 実装完了後のテスト追加ではなく、同時作成を徹底
3. **動作優先思考**: 動くだけでなく保守可能なコードを意識
4. **コードレビュー軽視**: 自動生成コードも人間の視点でレビュー

### 推奨アプローチ
1. **段階的実装**: 大きな機能を小さな単位に分割して実装
2. **継続的品質管理**: 実装と並行して品質基準をチェック
3. **積極的リファクタリング**: 技術的負債を蓄積させない
4. **チーム標準遵守**: プロジェクト固有の規約を一貫して適用

## まとめ

このガイドラインは、AI Agentによるコード生成の利点を活かしながら、品質・保守性・拡張性を確保するための実践的な指針です。短期的な開発速度よりも長期的なプロジェクト成功を重視し、技術的負債の蓄積を防ぐことを最優先としています。

すべての実装において、このガイドラインを遵守し、持続可能で高品質なコードベースの構築を目指してください。